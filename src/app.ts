import { glob, readFile, writeFile } from 'node:fs/promises'
import * as path from "node:path"
import * as ts from "typescript"
import { wrapTestFunction } from "./funcwrapper.js"
import { mergeImports, splitImport } from "./import.js"
import { collectExampleCodes, extractComments, parseTSDoc } from "./parser.js"
import { print } from "./printer.js"

export interface GenerateOptions {
  /** @default "test" */
  testFunctionName: string
  /** @default ".example.test" */
  testFileExtension: string
  /**
   * This is where you can adapt the generated code to your favorite test runner:
   *
   * For Jest, leave it empty, Jest adds its functions in the global scope
   *
   * For vitest, use `headers: ["import { test, expect } from 'vitest'", "â€¦"]`
   */
  headers: string[]
  /**
   * Keywords the example body must contain to be included in the generated tests.
   * @default ['assert', 'expect']
   */
  includeExampleContaining: string[];
}
const defaultOptions: GenerateOptions = {
  testFunctionName: "test",
  testFileExtension: ".example.test",
  headers: [],
  includeExampleContaining: ['assert', 'expect']
}

/**
 * Generate test files from JSDoc comments.
 * @example default
 * ```ts
 * import { generate } from "generate-jsdoc-example-tests"
 *
 * generate("./src/**")
 *   .then(() => console.info('tests generated'))
 *   .catch(console.error)
 * ```
 * @example with options for Vitest
 * ```ts
 * import { generate } from "generate-jsdoc-example-tests"
 *
 * generate("./src/**", {
 *   testFunctionName: 'it',
 *   header: 'import { it, expect } from "vitest"',
 *   testFileExtension: '.generated.test',
 *   includeExampleContaining: ['expect'],
 * })
 *   .then(() => console.info('tests generated'))
 *   .catch(console.error)
 * ```
 */
export async function generateTests(pattern, providedOptions?: Partial<GenerateOptions>) {
  const options = { ...defaultOptions, ...providedOptions }
  for await (const fileName of glob(pattern)) {
    if (fileName.includes(options.testFileExtension)) continue
    await generateTestFile(fileName, options)
  }
}


async function generateTestFile(
  filePath: string,
  options: GenerateOptions,
) {
  const { ext, name, dir } = path.parse(filePath)

  let kind
  switch (ext.toUpperCase()) {
    case ".TS":
      kind = ts.ScriptKind.TS
      break
    case ".JS":
      kind = ts.ScriptKind.JS
      break
    case ".TSX":
    case ".JSX":
      console.log("currently unsupported tsx ", filePath)
      return
    default:
      return
  }

  const source = ts.createSourceFile(
    filePath,
    await readFile(filePath, 'utf-8'),
    ts.ScriptTarget.Latest,
    false,
    kind,
  )

  const foundComments = extractComments(source)

  if (foundComments.length === 0) {
    // console.debug(`${filePath} comments not found`)
    return
  }

  const { imports, testBody } = foundComments
    .map((f) => {
      return { docNode: parseTSDoc(f), node: f.compilerNode }
    })
    .map(({ docNode, node }) => {
      return collectExampleCodes(node, source, docNode, options)
    })
    .flat()
    .map((example) => {
      return {
        ...example,
        exampleSource: ts.createSourceFile(
          example.name,
          example.code,
          ts.ScriptTarget.Latest,
          false,
          kind,
        ),
      }
    })
    .reduce(
      (acc, { /* source, */ exampleSource, name }) => {
        const { imports, body } = splitImport(exampleSource)

        // const fileName = path.relative(process.cwd(), source.fileName)
        const funcName = name || `Example ${++acc.counter}`

        const testBody = wrapTestFunction(funcName, body, options)
        return {
          ...acc,
          imports: [...acc.imports, ...imports],
          testBody: [...acc.testBody, testBody],
        }
      },
      { imports: [], testBody: [], counter: 0 },
    )

  const mergedImports = mergeImports(imports)

  if (testBody.length === 0) return // do not generate an empty test file.

  const ast = ts.factory.updateSourceFile(
    ts.createSourceFile(
      filePath + options.testFileExtension,
      "",
      ts.ScriptTarget.Latest,
      false,
      kind,
    ),
    [...mergedImports, ...testBody],
  )

  const banner = `// DO NOT EDIT: Code generated by "generate-jsdoc-example-tests".`
  if (options.headers.length > 0) options.headers.push('') // add empty line.
  const header = [banner, ...options.headers].join("\n")
  const printed = await print(ast, options)

  await writeFile(
    `${dir}/${name}${options.testFileExtension}${ext}`,
    `${header}\n${printed}`,
  )
}
