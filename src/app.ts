import { readFileSync, writeFileSync } from "fs"
import * as path from "path"
import * as ts from "typescript"
import { wrapTestFunction } from "./funcwrapper.js"
import { mergeImports, splitImport } from "./import.js"
import { collectExampleCodes, extractComments, parseTSDoc } from "./parser.js"
import { print } from "./printer.js"

export interface GenerateOptions {
  /** @default "test" */
  testFunctionName: string
  /** @default ".example.test.ts" */
  testFileExtension: string
  /**
   * This is where you can adapt the generated code to your favorite test runner:
   *
   * For Jest, leave it empty, Jest adds its functions in the global scope
   *
   * For vitest, use `header: "import { test, expect } from 'vitest'"`
   */
  header: string
}
const defaultOptions: GenerateOptions = {
  testFunctionName: "test",
  testFileExtension: ".example.test.ts",
  header: "",
}

export async function generate(
  filePath: string,
  providedOptions?: Partial<GenerateOptions>,
) {
  const options = { ...defaultOptions, ...providedOptions }
  const { ext, name, dir } = path.parse(filePath)

  let kind
  switch (ext.toUpperCase()) {
    case ".TS":
      kind = ts.ScriptKind.TS
      break
    case ".TSX":
      kind = ts.ScriptKind.TSX
      console.log("currently unsupported tsx ", filePath)
      return
    default:
      console.log("unknown file extension ", filePath)
      return
  }

  const source = ts.createSourceFile(
    filePath,
    readFileSync(filePath).toString(),
    ts.ScriptTarget.Latest,
    false,
    kind,
  )

  const foundComments = extractComments(source)

  if (foundComments.length === 0) {
    console.log(`${filePath} comments not found`)
    return
  }

  const { imports, testBody } = foundComments
    .map((f) => {
      return { docNode: parseTSDoc(f), node: f.compilerNode }
    })
    .map(({ docNode, node }) => {
      return collectExampleCodes(node, source, docNode)
    })
    .flat()
    .map((example) => {
      return {
        ...example,
        exampleSource: ts.createSourceFile(
          example.name,
          example.code,
          ts.ScriptTarget.Latest,
          false,
          kind,
        ),
      }
    })
    .reduce(
      (acc, { source, exampleSource, name }) => {
        const { imports, body } = splitImport(exampleSource)

        const fileName = path.relative(process.cwd(), source.fileName)
        const funcName = name || `./${fileName}_${acc.counter++}`

        const testBody = wrapTestFunction(funcName, body, options)
        return {
          ...acc,
          imports: [...acc.imports, ...imports],
          testBody: [...acc.testBody, testBody],
        }
      },
      { imports: [], testBody: [], counter: 0 },
    )

  const mergedImports = mergeImports(imports)

  const ast = ts.factory.updateSourceFile(
    ts.createSourceFile(
      filePath + options.testFileExtension,
      "",
      ts.ScriptTarget.Latest,
      false,
      kind,
    ),
    [...mergedImports, ...testBody],
  )

  const banner = `// DO NOT EDIT: Code generated by "generate-jsdoc-example-tests".`
  const header = [banner, options.header].filter(Boolean).join("\n")
  const printed = await print(ast, options)

  writeFileSync(
    `${dir}/${name}${options.testFileExtension}`,
    `${header}\n${printed}`,
  )
}
